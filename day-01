一.下面这段代码输出的内容
package main

 import (
     "fmt"
 )

 func main() {
     defer_call()
 }

func defer_call() {
    defer func() { fmt.Println("打印前") }()
    defer func() { fmt.Println("打印中") }()
    defer func() { fmt.Println("打印后") }()
    panic("触发异常")
}
看下答案，输出：

    打印后
    打印中
    打印前
    panic: 触发异常
参考解析：defer 的执行顺序是后进先出。当出现 panic 语句的时候，会先按照 defer 的后进先出的顺序执行，最后才会执行panic
个人总结：defer语句以栈的方式进行存储和运行，优先于panic运行

----------------------------------------------------------------------------------------------------------------------
二.下面这段代码输出什么，说明原因。
func main() {

     slice := []int{0,1,2,3}
     m := make(map[int]*int)

     for key,val := range slice {
         m[key] = &val
     }

    for k,v := range m {
        fmt.Println(k,"->",*v)
    }
}
直接给答案：

    0 -> 3
    1 -> 3
    2 -> 3
    3 -> 3
参考解析：这是新手常会犯的错误写法，for range 循环的时候会创建每个元素的副本，而不是元素的引用，所以 m[key] = &val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3.

正确的写法:

func main() {

     slice := []int{0,1,2,3}
     m := make(map[int]*int)

     for key,val := range slice {
         value := val
         m[key] = &value
     }

    for k,v := range m {
        fmt.Println(k,"===>",*v)
    }
}
个人总结：m[key] = &val传递的是val变量的指针

----------------------------------------------------------------------------------------------------------------------

三.
1.下面两段代码输出什么。
// 1.
 func main() {
     s := make([]int, 5)
     s = append(s, 1, 2, 3)
     fmt.Println(s)
 }

// 2.
 func main() {
    s := make([]int,0)
    s = append(s,1,2,3,4)
    fmt.Println(s)
}
两段代码分别输出：

    [0 0 0 0 0 1 2 3]
    [1 2 3 4]
参考解析：这道题考的是使用 append 向 slice 添加元素，第一段代码常见的错误是 [1 2 3]，需要注意。
个人总结：s : mkae([]int, 5)创建的s=={0,0,0,0,0},append方法是在原切片后面增加元素

2.下面这段代码有什么缺陷
    func funcMui(x,y int)(sum int,error){
        return x+y,nil
    }
参考答案：第二个返回值没有命名。

参考解析：

在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。这里的第一个返回值有命名 sum，第二个没有命名，所以错误。
个人总结：一定要注意编程语法规范

3.new() 与 make() 的区别
参考答案：

new(T) 和 make(T,args) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。

new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。

make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.
个人总结：new(T)传递的是指针，适用于值类型如数组，结构体，值类型还有int，float,bool,string等，make(T,args)传递的是经过初始化后T的引用，只适用于slice,map,channel

----------------------------------------------------------------------------------------------------------------------
四.

